<post>
  <title>Zero to HTTPS on DigitalOcean</title>
  <author>David Kerkeslager</author>
  <body>
    <p>
      I just set up this blog. I haven't done any server administration stuff in a while, so I had to update my skills to get it running. Here's a basic outline of what I did; I'll probably come back and update this the next time I set up a server, or even as I make changes to the server. There are lots of tutorials online that are pretty similar to this; this is mostly for me, so I don't have to find those tutorials.
    </p>

    <section>
      <header>Creating the Server</header>
      <p>
        I used <a href='https://www.digitalocean.com/'>DigitalOcean</a> to set up the server. I won't go into this too deeply, because they have a pretty straightforward UI. Here are the configurtion options I chose:
      </p>
      <ul>
        <li>Debian 8.3 x64</li>
        <li>Turned on IPv6</li>
        <li>Added my SSH Key</li>
      </ul>
    </section>

    <section>
      <header>SSH Local Configuration</header>
      <p>
        As a convenience for myself, I added a section to my <code>~/.ssh/config</code>. This allows me to SSH into the server just by typing <code>ssh servername</code>.
      </p>
      <code>Host servername             # The name you want to type after `ssh`
    User root               # This is going to change later
    HostName 12.34.56.78    # The IP Address of the server
    IdentityFile ~/.ssh/key # The SSH key you added when setting up the server
      </code>
    </section>

    <section>
      <header>Creating a user with <code>sudo</code> privileges</header>
      <p>
        The basic settings don't have a secure environment to serve static files from (which is my goal). So we want to SSH into our server as <code>root</code> (the only user available on the system right now) and secure the server.
      </p>
      <p>
        SSH into the server with <code>ssh servername</code> (<code>servername</code> should be the name of the server you set up in your SSH config). 
      </p>
      <p>
        Next, we want to set up a user who can SSH into the server and use <code>sudo</code> so we don't have to operate as <code>root</code>. I created a user named <code>kerkeslager</code>:
      </p>
      <ol>
        <li>Create a user using <code>adduser kerkeslager</code>.</li>
        <li>Create a password<footnote>I used <a href='http://world.std.com/~reinhold/diceware.html'>DiceWare</a>.</footnote> and fill out the rest of your user's details.</li>
        <li>Install <code>vim</code> with <code>apt-get install vim</code>. Then call <code>export VISUAL=vim; visudo</code> to edit your superusers file with <code>vim</code>. Under the <code>root</code> user's privilege specification, you'll want to add a line that looks like <code>kerkeslager ALL=(ALL:ALL) ALL</code>.</li>
        <li>Create an SSH directory for your new user and move your SSH key into their <code>authorized_keys</code> so you can use that key to log in as that user, like so:
        <br/><br/><code>mkdir /home/kerkeslager/.ssh
cp ~/.ssh/authorized_keys /home/kerkeslager/.ssh/authorized_keys
chmod 700 /home/kerkeslager/.ssh
chmod 600 /home/kerkeslager/.ssh/authorized_keys
chown -R kerkeslager:kerkeslager /home/kerkeslager/.ssh/</code></li>
      </ol>
      <p>
        You should now be able to log off the server with <code>exit</code> and SSH in as the user you created. To do this all the time in the future, change <code>root</code> in your <code>~/.ssh/config</code> to the name of the user you created.
      </p>
    </section>
    <section>
      <header>Securing SSH</header>
      <p>
        Now that you're logged in as your new privileged user, update the software on the server with <code>sudo apt-get update && sudo apt-get dist-upgrade</code>. This gives you an opportunity to find out if you set up the privileges from the previous section correctly.
      </p>
      <p>
        Next we'll want to configure SSH so to be a little more secure. Open <code>/etc/ssh/sshd_config</code> and make the following changes<footnote>A lot of guides online recommend changing the port on which the SSH daemon serves so that an attacker has to scan ports to find what port you're serving on. This is a classic example of <a href='https://en.wikipedia.org/wiki/Security_through_obscurity'>security through obscurity</a>. Surely an attacker capable of breaking into SSH is capable of scanning your ports for SSH. This only serves to inconience those who forget which port they configured after choosing to engage in this <a href='https://en.wikipedia.org/wiki/Security_theater'>security theater</a>.</footnote>:
      </p>
      <ol>
        <li>Change <code>PermitRootLogin yes</code> to <code>PermitRootLogin no</code>. This prevents the <code>root</code> user from logging in.</li>
        <li>Add <code>AllowUsers kerkeslager</code> to allow your user to log in.</li>
        <li>Add <code>PasswordAuthentication no</code> to force users to log in with an SSH key, which is much more secure than a username and password.</li>
        <li>Change <code>UsePAM yes</code> to <code>UsePAM no</code> to prevent it from using PAM to authenticate passwords.</li>
      </ol>
      <p>
        Save the file and reload your config with <code>sudo service sshd reload</code>.
      </p>
    </section>
    
    <section>
      <header>Setting up a firewall</header>
      <p>
        The biggest improvement since the last time I set up a server is the popularization of <a href='https://launchpad.net/ufw'>Uncomplicated Firewall</a>. This streamlines the process of locking down the server's <code>netfilter</code> settings significantly:
      </p>
      <ol>
        <li><code>sudo apt-get install ufw</code> to install Uncomplicated Firewall.</li>
        <li><code>sudo ufw default deny incoming</code> to only allow whitelisted incoming traffic.</li>
        <li><code>sudo ufw default allow outgoing</code> to allow all outgoing traffic.</li>
        <li><code>sudo ufw allow ssh</code> to allow SSH connections.</li>
        <li><code>sudo ufw allow 80/tcp</code> and <code>sudo ufw allow 443/tcp</code> to allow HTTP and HTTPS respectively.</li>
        <li>Code list your rules with <code>sudo ufw show added</code> and check them.</li>
        <li><code>sudo ufw enable</code> to apply the changes, start the firewall, and set the rules to apply on reboot.</li>
      </ol>
    </section>

    <section>
      <header>Setting up NGINX to serve over HTTP</header>
      <p>
        I use NGINX to serve up static files. To install NGINX, do <code>sudo apt-get install -y nginx</code>. Start NGINX with <code>sudo service nginx start</code>.
      </p>
      <p>At this point you should be able to visit the IP address of your server (which can be found on the Droplets tab of the DigitalOcean console) in a browser and view the NGINX welcome message. We'll need to create a server serving from a webroot in order to set up HTTPS later, so let's do that now:</p>
      <ol>
        <li>Use <code>sudo nginx /etc/nginx/nginx.conf</code> to edit your NGINX configuration. This is the base configuration that configures all the sites running through NGINX on this server.</li>
        <li>You'll see a line that says <code>include /etc/nginx/sites-enabled/default</code>. This imports the server file for the default site, which is the NGINX welcome message you saw if you visited your server's IP in a browser. We want to create our own site, so let's change that to say something like <code>include /etc/nginx/sites-enabled/kerkeslager.com;</code>. Save and exit the file.</li>
        <li>Now we need to create the server file that we just referenced. To do that, use <code>sudo vim /etc/nginx/sites-enabled/kerkeslager.com</code> and paste in the following code:<code>
server {
    listen 80;
    listen [::]:80;

    root /var/www/kerkeslager.com;
}
</code>
This isn't a production-worthy NGINX server, but we'll come back and fix it later. For now it's enough to serve up our static files from the proper webroot so we can serve the keys for the certification process we're about to set up.</li>
        <li>Now we need to create the folder that our webroot points to. First, create a directory under <code>/var/www</code> with a command that looks something like <code>sudo mkdir /var/www/kerkeslager.com</code>. Put whatever HTML files you want to serve in that folder.</li>
        <li>Finally, load your new configuration with <code>sudo service nginx restart</code>. You should be able to visit your server's IP address in a browser and view the static files you added.</li>
      </ol>
      <p>NOTE: One gotcha I ran into here is that NGINX must have read permissions on the files you want served and read <em>and execute</em> permissions on all the directories you want served. Needing execute permission on directories was a bit unintuitive to me. You'll know you have this problem if NGINX serves you a page saying "Permission Denied". To fix it, set your directory permissions to read/execute with <code>chmod 755 dirname/</code> and your file permissions to read with <code>chmod 644</code>.</p>
    </section>

    <section>
      <header>DNS Configuration</header>
      <p>The way to do this is dependent on your domain name registrar. I used <a href='https://www.gandi.net/'>Gandi</a> to register <code>kerkeslager.com</code>. They have a tool for setting up your zone records, and so does every other domain name registrar I've used. Whatever tool you use, you'll want to set up A and AAAA records for your naked domain and www subdomain. A records point to your IPv4 address, while AAAA records point to your IPv6 address. For reasons why you want to use a www subdomain, see <a href='https://www.yes-www.org/why-use-www/'>Why use www?</a>. Whatever tools you use to set this up, your configuration should end up looking something like this:</p>
      <table>
        <tr>
          <th>Name</th>
          <th>Type</th>
          <th>Value</th>
          <th>TTL</th>
        </tr>

        <tr>
          <td>@</td>
          <td>A</td>
          <td>162.243.98.178</td>
          <td>3h</td>
        </tr>

        <tr>
          <td>www</td>
          <td>A</td>
          <td>162.243.98.178</td>
          <td>3h</td>
        </tr>

        <tr>
          <td>@</td>
          <td>AAAA</td>
          <td>2604:a880:0:1010::629:7001</td>
          <td>3h</td>
        </tr>

        <tr>
          <td>www</td>
          <td>AAAA</td>
          <td>2604:a880:0:1010::629:7001</td>
          <td>3h</td>
        </tr>
      </table>
    </section>

    <section>
      <header>Getting certs from LetsEncrypt</header>
      <p>Next I set up HTTPS with <a href='https://letsencrypt.org/'>Let's Encrypt</a>.</p>
      <p>
        To get the Let's Encrypt client you'll need to install <code>git</code> with <code>sudo apt-get install -y git</code>. Once you have this, you can obtain the Let's Encrypt client by running <code>git clone https://github.com/letsencrypt/letsencrypt</code>.
      </p>
      <p>
        From inside the git repository, run <code>./letsencrypt-auto certonly --webroot -w /var/www/kerkeslager -d kerkeslager.com -d www.kerkeslager.com</code>.
      </p>
      <p>
        After going through the prompts, you should have a working set of keys for your HTTPS configuration.
      </p>
    </section>

    <section>
      <header>Setting up NGINX to serve over HTTPS</header>
      <p>Finally, we need to set up NGINX to serve over HTTPS. To do this, go back and edit the site configuration you created, in my case <code>/var/www/kerkeslager.com</code>. Delete the existing server and replace it with this:<code>
server {
        # Listen for HTTP requests on the naked domain or www subdomain
        listen 80;
        listen [::]:80;
        server_name kerkeslager.com www.kerkeslager.com;

        # Serve the proof that you own the server for LetsEncrypt
        location '/.well-known/acme-challenge' {
                default_type "text/plain";
                root /tmp/letsencrypt-auto;
        }

        # Redirect all other HTTP requests to HTTPS on the www subdomain
        location / {
                return 301 https://www.kerkeslager.com$request_uri;
        }
}

server {
        # Listen for HTTPS requests to the naked domain
        listen 443 ssl;
        listen [::]:443 ssl;
        server_name kerkeslager.com;

        # Redirect to the www subdomain
        return 301 https://www.kerkeslager.com$request_uri;

        ssl_certificate /etc/letsencrypt/live/kerkeslager.com/fullchain.pem;
        ssl_certificate_key /etc/letsencrypt/live/kerkeslager.com/privkey.pem;
        ssl_stapling on;
        ssl_stapling_verify on;
}

server {
        # Listen for HTTPS requests to the www subdomain
        listen 443 ssl default_server;
        listen [::]:443 ssl default_server;
        server_name www.kerkeslager.com;

        # Serve static files from /var/www/kerkeslager.com/
        root /var/www/kerkeslager.com;

        ssl_certificate /etc/letsencrypt/live/kerkeslager.com/fullchain.pem;
        ssl_certificate_key /etc/letsencrypt/live/kerkeslager.com/privkey.pem;
        ssl_stapling on;
        ssl_stapling_verify on;
}

</code></p>
      <p>You'll notice there are three servers there. The first listens over HTTP and redirects all traffic to HTTPS. The second redirects traffic from the naked <code>https://kerkeslager.com</code> domain to the <code>https://www.kerkeslager.com</code> subdomain. The final server actually serves up our static files from the webroot over HTTPS, using the LetsEncrypt certification we created.</p>
      <p>You should now be able to visit your domain and view your site over HTTPS!</p>
    </section>
  </body>
</post>
